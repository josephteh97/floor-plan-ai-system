import json
import numpy as np

def generate_3d_model(analysis_data: dict):
    """
    Converts 2D analysis data into 3D model specifications.
    Returns a dictionary suitable for 3D rendering (e.g., Three.js)
    and can be exported to OBJ/IFC.
    """
    
    model_3d = {
        "walls": [],
        "floors": [],
        "doors": [],
        "windows": [],
        "rooms": []
    }
    
    height = analysis_data.get("metadata", {}).get("height", 1000)
    # Default wall height in meters (assuming scale)
    # If no scale found, we use pixel units directly for MVP
    wall_height = 3.0 
    scale_ratio = analysis_data.get("scale_ratio", 1.0) # pixels per meter
    
    # Process Elements
    for element in analysis_data.get("elements", []):
        etype = element.get("type")
        box = element.get("box") # [x1, y1, x2, y2]
        
        if etype == "wall":
            # If it's a box (YOLO), center line is (x1+x2)/2
            # If it's a line (OpenCV), it is [x1, y1, x2, y2]
            
            # Simple assumption: All walls are rectangular boxes for 3D gen
            w_width = abs(box[2] - box[0])
            w_length = abs(box[3] - box[1])
            
            # Heuristic: If one dimension is much smaller, it's the thickness
            if w_width < w_length:
                thickness = w_width
                length = w_length
                # Center
                cx = (box[0] + box[2]) / 2
                cy = (box[1] + box[3]) / 2
                angle = 0 # Vertical wall
            else:
                thickness = w_length
                length = w_width
                cx = (box[0] + box[2]) / 2
                cy = (box[1] + box[3]) / 2
                angle = 90 # Horizontal wall
            
            model_3d["walls"].append({
                "center": [cx, cy],
                "length": length,
                "thickness": thickness,
                "height": wall_height * 100, # visual scale
                "angle": angle
            })
            
        elif etype == "door":
             model_3d["doors"].append({
                "box": box,
                "height": 2.1 * 100
            })
             
        elif etype == "window":
             model_3d["windows"].append({
                "box": box,
                "height": 1.5 * 100,
                "elevation": 1.0 * 100
            })

    # Process Rooms (Labels) to create Floors
    # For MVP, we don't have full polygon loops, so we just place text markers
    for room in analysis_data.get("rooms", []):
        model_3d["rooms"].append({
            "name": room["name"],
            "position": room["position"]
        })

    return model_3d

def export_to_obj(model_3d: dict) -> str:
    """
    Export the 3D model to Wavefront OBJ format string.
    """
    vertices = []
    faces = []
    
    # Helper to add a cube (wall)
    def add_cube(center, length, thickness, height):
        idx = len(vertices) + 1
        x, y = center
        l2 = length / 2
        t2 = thickness / 2
        
        # 8 vertices
        # Bottom
        vertices.append(f"v {x-l2} 0 {y-t2}")
        vertices.append(f"v {x+l2} 0 {y-t2}")
        vertices.append(f"v {x+l2} 0 {y+t2}")
        vertices.append(f"v {x-l2} 0 {y+t2}")
        # Top
        vertices.append(f"v {x-l2} {height} {y-t2}")
        vertices.append(f"v {x+l2} {height} {y-t2}")
        vertices.append(f"v {x+l2} {height} {y+t2}")
        vertices.append(f"v {x-l2} {height} {y+t2}")
        
        # Faces (quads)
        # Bottom
        faces.append(f"f {idx} {idx+1} {idx+2} {idx+3}")
        # Top
        faces.append(f"f {idx+4} {idx+5} {idx+6} {idx+7}")
        # Sides
        faces.append(f"f {idx} {idx+1} {idx+5} {idx+4}")
        faces.append(f"f {idx+1} {idx+2} {idx+6} {idx+5}")
        faces.append(f"f {idx+2} {idx+3} {idx+7} {idx+6}")
        faces.append(f"f {idx+3} {idx} {idx+4} {idx+7}")

    for wall in model_3d["walls"]:
        add_cube(wall["center"], wall["length"], wall["thickness"], wall["height"])
        
    obj_lines = ["# Generated by Floor Plan AI"]
    obj_lines.extend(vertices)
    obj_lines.extend(faces)
    
    return "\n".join(obj_lines)
